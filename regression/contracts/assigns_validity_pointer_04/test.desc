KNOWNBUG
main.c
--enforce-contract foo --replace-call-with-contract bar --replace-call-with-contract baz _ --pointer-primitive-check
^EXIT=0$
^SIGNAL=0$
^VERIFICATION SUCCESSFUL$
// bar
ASSERT \*foo::x > 0
IF Â¬\(\*foo::x = 3\) THEN GOTO \d
ASSIGN goto_convertt::tmp_if_expr := \(\*foo::1::y = 5 \? true : false\)
ASSUME .*::tmp_if_expr
// baz
ASSUME \*z = 7
--
--
This test checks support for a malloced pointer that is assigned to by
a function (bar and baz). Both functions bar and baz are being replaced by
their function contracts, while the calling function foo is being checked
(by enforcing it's function contracts).

BUG: `z` is being assigned to in `foo`, but is not in `foo`s assigns clause!
This test is expected to pass but it should not.
It somehow used to (and still does on *nix), but that seems buggy.
Most likely the bug is related to `freely_assignable_symbols`,
which would be properly fixed in a subsequent PR.
