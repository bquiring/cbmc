CORE
main.c
--enforce-all-contracts _ --pointer-primitive-check
^EXIT=10$
^SIGNAL=0$
^\[bar.\d+\] line \d+ Check that \*b is assignable: SUCCESS$
^\[foo.\d+\] line \d+ Check that a is assignable: SUCCESS$
^\[foo.\d+\] line \d+ Check that yp is assignable: SUCCESS$
^\[foo.\d+\] line \d+ Check that z is assignable: SUCCESS$
^\[foo.\d+\] line \d+ Check that \*xp is assignable: SUCCESS$
^\[foo.\d+\] line \d+ Check that y is assignable: FAILURE$
^.* 1 of \d+ failed \(\d+ iteration.*\)$
^VERIFICATION FAILED$
--
^\[foo.\d+\] line \d+ Check that a is assignable: FAILURE$
^\[foo.pointer\_primitives.\d+\] line \d+ deallocated dynamic object in POINTER_OBJECT\(tmp\_cc\$\d+\): FAILURE$
^.* 3 of \d+ failed (\d+ iterations)$
--
Checks whether contract enforcement works with functions that deallocate memory.
We had problems before when freeing a variable, but still keeping it on
the writable set, which lead to deallocated variables issues.
Now, if a memory is deallocated, we remove it from the our freely assignable set.
